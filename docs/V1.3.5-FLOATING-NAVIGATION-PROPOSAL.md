# MD Viewer v1.3.5 - 功能增强方案（修订版）

> **版本**: v1.3.5
> **功能**: 浮动导航 + HTML 导出增强
> **日期**: 2026-01-07
> **状态**: 已根据评审意见修订
> **修订版本**: v2.0

---

## 修订说明

本方案已根据以下评审意见进行重大修改：

| 评审来源 | 主要发现 | 修订内容 |
|----------|----------|----------|
| 前端架构评审 | 正则方案缺陷、无 a11y、性能问题 | 改用 Token 流、添加完整 a11y |
| 安全审计 | XSS 漏洞、SVG 未清理 | 添加 DOMPurify、严格模式 |
| 架构评审 | 缺少分层、技术债务高 | 引入 Application Layer |
| 代码评审 | 边界情况处理不足 | 完善代码逻辑 |

---

## 功能清单

| 功能 | 说明 | 优先级 |
|------|------|--------|
| **浮动导航** | 渲染区右侧：到顶/到底/目录 | P0 |
| **HTML 导出增强** | Mermaid 图表安全渲染为 SVG | P0 |

---

# 第一部分：浮动导航功能

## 一、功能概述

在 Markdown 渲染区右侧添加**浮动导航条**，包含：

| 功能 | 说明 |
|------|------|
| **一键到顶** | 平滑滚动到文档顶部 |
| **一键到底** | 平滑滚动到文档底部 |
| **目录大纲** | 展开/收起文档标题结构，点击跳转 |
| **当前位置高亮** | 目录中高亮当前可视章节 |

---

## 二、架构设计

### 2.1 分层架构（修订）

```
┌─────────────────────────────────────────────────────────┐
│  Presentation Layer (组件层)                             │
│  ├─ FloatingNav.tsx      - 浮动导航容器                  │
│  ├─ TocPanel.tsx         - 目录面板（含 a11y）           │
│  └─ TocItem.tsx          - 目录项（支持键盘导航）         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Application Layer (应用层) - 新增                       │
│  ├─ useTableOfContents.ts  - 目录状态管理 + 防抖         │
│  └─ useActiveHeading.ts    - 当前位置追踪                │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  Domain Layer (领域层)                                   │
│  ├─ tocExtractor.ts      - 基于 Token 流的目录提取       │
│  └─ slugify.ts           - 共享的 slug 生成逻辑          │
└─────────────────────────────────────────────────────────┘
```

### 2.2 数据流

```
Markdown Content
       ↓
  markdown-it.parse()
       ↓
    Token[]
       ↓
  extractTocFromTokens()
       ↓
    TocItem[]
       ↓
  useTableOfContents (防抖 300ms)
       ↓
  FloatingNav → TocPanel → TocItem
```

---

## 三、UI 设计方案

### 3.1 布局位置

```
┌─────────────────────────────────────────────────────────┐
│  [Tab Bar]                                              │
├─────────────────────────────────────────────────────────┤
│                                                    ┌───┐│
│                                                    │ ▲ ││  ← 到顶
│                                                    ├───┤│
│           Markdown 渲染内容                         │ ≡ ││  ← 目录
│                                                    ├───┤│
│                                                    │ ▼ ││  ← 到底
│                                                    └───┘│
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**定位策略**：
- 桌面端：`position: absolute` 相对于预览区容器（修订：避免遮挡）
- 移动端：`position: fixed` 底部 FAB 按钮 + 底部抽屉

### 3.2 图标方案

| 功能 | 图标 | Unicode |
|------|------|---------|
| 到顶 | `▲` | U+25B2 |
| 目录 | `≡` | U+2261 |
| 到底 | `▼` | U+25BC |
| 关闭 | `✕` | U+2715 |

### 3.3 交互设计（含 a11y）

| 交互 | 行为 | a11y 支持 |
|------|------|-----------|
| 点击到顶/底 | 平滑滚动 | aria-label |
| 点击目录按钮 | 展开/收起面板 | aria-expanded |
| 点击目录项 | 滚动到标题 + 焦点转移 | 焦点管理 |
| Tab 键 | 在目录项间导航 | tabindex |
| Enter 键 | 激活当前目录项 | onKeyDown |
| Escape 键 | 关闭目录面板 | 焦点返回按钮 |

### 3.4 目录面板设计

```
┌─────────────────────────┐
│ 目录                  ✕ │  ← role="navigation"
├─────────────────────────┤
│ ● 一级标题        ←──── │  ← 当前位置高亮
│   ○ 二级标题            │
│   ○ 二级标题            │
│     · 三级标题          │
│   ○ 二级标题            │
│ ● 一级标题              │
└─────────────────────────┘
```

**特性**：
- 最大高度：`60vh`，超出滚动
- 最大宽度：`280px`
- 当前可视标题高亮（IntersectionObserver）
- 完整键盘导航支持

---

## 四、技术实现方案（修订版）

### 4.1 共享 Slug 生成模块（新增）

```typescript
// src/renderer/src/utils/slugify.ts

/**
 * 生成 URL 友好的 slug
 * 与 markdownRenderer.ts 共享同一逻辑，确保一致性
 */
export function slugify(text: string): string {
  const slug = text
    .toLowerCase()
    .trim()
    // 保留字母（含中日韩）、数字、空格、连字符
    .replace(/[^\p{L}\p{N}\s-]/gu, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '')

  return slug || `heading-${Math.random().toString(36).slice(2, 8)}`
}

/**
 * 生成唯一 slug（处理重复标题）
 */
export function uniqueSlugify(
  text: string,
  usedSlugs: Map<string, number>
): string {
  const baseSlug = slugify(text)
  const count = usedSlugs.get(baseSlug) || 0
  const slug = count > 0 ? `${baseSlug}-${count}` : baseSlug
  usedSlugs.set(baseSlug, count + 1)
  return slug
}
```

### 4.2 目录提取（修订：基于 Token 流）

```typescript
// src/renderer/src/utils/tocExtractor.ts

import type { Token } from 'markdown-it'
import { uniqueSlugify } from './slugify'

export interface TocItem {
  id: string
  text: string
  level: number
}

/**
 * 从 markdown-it Token 流中提取目录
 * 优点：与渲染结果 100% 一致，自动处理代码块等边界情况
 */
export function extractTocFromTokens(tokens: Token[]): TocItem[] {
  const toc: TocItem[] = []
  const usedSlugs = new Map<string, number>()

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i]

    if (token.type === 'heading_open') {
      const level = parseInt(token.tag.slice(1)) // h1 -> 1
      const inlineToken = tokens[i + 1]

      // 提取纯文本内容（排除 Markdown 语法）
      const text = inlineToken.children
        ?.filter(t => t.type === 'text' || t.type === 'code_inline')
        .map(t => t.content)
        .join('')
        .trim() || ''

      if (!text) continue

      const id = uniqueSlugify(text, usedSlugs)
      toc.push({ id, text, level })
    }
  }

  return toc
}

/**
 * 便捷方法：直接从 Markdown 字符串提取目录
 */
export function extractToc(markdown: string, md: MarkdownIt): TocItem[] {
  const tokens = md.parse(markdown, {})
  return extractTocFromTokens(tokens)
}
```

### 4.3 应用层 Hooks（新增）

```typescript
// src/renderer/src/hooks/useTableOfContents.ts

import { useMemo, useCallback } from 'react'
import { useDebouncedValue } from './useDebouncedValue'
import { extractToc, TocItem } from '../utils/tocExtractor'
import { createMarkdownRenderer } from '../utils/markdownRenderer'

interface UseTableOfContentsOptions {
  debounceMs?: number
}

export function useTableOfContents(
  markdown: string,
  options: UseTableOfContentsOptions = {}
) {
  const { debounceMs = 300 } = options

  // 防抖处理，避免频繁解析
  const debouncedMarkdown = useDebouncedValue(markdown, debounceMs)

  // 缓存 markdown-it 实例
  const md = useMemo(() => createMarkdownRenderer(), [])

  // 提取目录
  const toc = useMemo(() => {
    if (!debouncedMarkdown) return []
    return extractToc(debouncedMarkdown, md)
  }, [debouncedMarkdown, md])

  // 滚动到指定标题
  const scrollToHeading = useCallback((
    id: string,
    container: HTMLElement | null
  ) => {
    if (!container) return

    const heading = container.querySelector(`#${CSS.escape(id)}`)
    if (!heading) return

    heading.scrollIntoView({ behavior: 'smooth', block: 'start' })

    // 焦点管理（a11y）
    const el = heading as HTMLElement
    el.setAttribute('tabindex', '-1')
    el.focus()
    el.addEventListener('blur', () => {
      el.removeAttribute('tabindex')
    }, { once: true })
  }, [])

  return { toc, scrollToHeading }
}
```

```typescript
// src/renderer/src/hooks/useActiveHeading.ts

import { useState, useEffect, useRef } from 'react'
import type { TocItem } from '../utils/tocExtractor'

/**
 * 追踪当前可视的标题（用于目录高亮）
 */
export function useActiveHeading(
  toc: TocItem[],
  container: HTMLElement | null
): string {
  const [activeId, setActiveId] = useState<string>('')
  const observerRef = useRef<IntersectionObserver | null>(null)

  useEffect(() => {
    if (!container || toc.length === 0) return

    // 断开旧的 observer
    observerRef.current?.disconnect()

    const observer = new IntersectionObserver(
      (entries) => {
        // 找到最上方可见的标题
        const visibleEntries = entries
          .filter(entry => entry.isIntersecting)
          .sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top)

        if (visibleEntries.length > 0) {
          setActiveId(visibleEntries[0].target.id)
        }
      },
      {
        root: container,
        rootMargin: '-10% 0px -80% 0px', // 顶部 10% 位置触发
        threshold: 0
      }
    )

    // 观察所有标题元素
    toc.forEach(({ id }) => {
      const el = container.querySelector(`#${CSS.escape(id)}`)
      if (el) observer.observe(el)
    })

    observerRef.current = observer

    return () => observer.disconnect()
  }, [toc, container])

  return activeId
}
```

```typescript
// src/renderer/src/hooks/useDebouncedValue.ts

import { useState, useEffect } from 'react'

export function useDebouncedValue<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay)
    return () => clearTimeout(timer)
  }, [value, delay])

  return debouncedValue
}
```

### 4.4 组件实现（含完整 a11y）

```typescript
// src/renderer/src/components/FloatingNav.tsx

import React, { useState, useRef, useEffect, useCallback } from 'react'
import { useTableOfContents } from '../hooks/useTableOfContents'
import { useActiveHeading } from '../hooks/useActiveHeading'
import TocPanel from './TocPanel'

interface FloatingNavProps {
  containerRef: React.RefObject<HTMLDivElement>
  markdown: string
}

const FloatingNav: React.FC<FloatingNavProps> = ({ containerRef, markdown }) => {
  const [showToc, setShowToc] = useState(false)
  const tocButtonRef = useRef<HTMLButtonElement>(null)

  const { toc, scrollToHeading } = useTableOfContents(markdown)
  const activeId = useActiveHeading(toc, containerRef.current)

  // 滚动到顶部
  const scrollToTop = useCallback(() => {
    containerRef.current?.scrollTo({ top: 0, behavior: 'smooth' })
  }, [containerRef])

  // 滚动到底部
  const scrollToBottom = useCallback(() => {
    const el = containerRef.current
    if (el) {
      el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' })
    }
  }, [containerRef])

  // ESC 关闭目录
  useEffect(() => {
    if (!showToc) return

    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setShowToc(false)
        tocButtonRef.current?.focus()
      }
    }

    document.addEventListener('keydown', handleEscape)
    return () => document.removeEventListener('keydown', handleEscape)
  }, [showToc])

  // 处理目录项点击
  const handleTocSelect = useCallback((id: string) => {
    scrollToHeading(id, containerRef.current)
    setShowToc(false)
  }, [scrollToHeading, containerRef])

  return (
    <nav className="floating-nav" aria-label="文档导航">
      {/* 到顶部按钮 */}
      <button
        className="floating-nav-btn"
        onClick={scrollToTop}
        aria-label="返回顶部"
        title="返回顶部"
      >
        ▲
      </button>

      {/* 目录按钮 */}
      {toc.length > 0 && (
        <button
          ref={tocButtonRef}
          className="floating-nav-btn"
          onClick={() => setShowToc(!showToc)}
          aria-label="目录"
          aria-expanded={showToc}
          aria-controls="toc-panel"
          title="目录"
        >
          ≡
        </button>
      )}

      {/* 到底部按钮 */}
      <button
        className="floating-nav-btn"
        onClick={scrollToBottom}
        aria-label="跳到底部"
        title="跳到底部"
      >
        ▼
      </button>

      {/* 目录面板 */}
      {showToc && toc.length > 0 && (
        <TocPanel
          toc={toc}
          activeId={activeId}
          onSelect={handleTocSelect}
          onClose={() => {
            setShowToc(false)
            tocButtonRef.current?.focus()
          }}
        />
      )}
    </nav>
  )
}

export default FloatingNav
```

```typescript
// src/renderer/src/components/TocPanel.tsx

import React, { useRef, useEffect } from 'react'
import type { TocItem } from '../utils/tocExtractor'

interface TocPanelProps {
  toc: TocItem[]
  activeId: string
  onSelect: (id: string) => void
  onClose: () => void
}

const TocPanel: React.FC<TocPanelProps> = ({ toc, activeId, onSelect, onClose }) => {
  const panelRef = useRef<HTMLElement>(null)
  const firstItemRef = useRef<HTMLAnchorElement>(null)

  // 打开时焦点移到第一个项目
  useEffect(() => {
    firstItemRef.current?.focus()
  }, [])

  // 键盘导航
  const handleKeyDown = (e: React.KeyboardEvent, id: string) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault()
      onSelect(id)
    }
  }

  return (
    <aside
      id="toc-panel"
      ref={panelRef}
      className="toc-panel"
      role="navigation"
      aria-label="文档目录"
    >
      <div className="toc-panel-header">
        <span className="toc-panel-title">目录</span>
        <button
          className="toc-panel-close"
          onClick={onClose}
          aria-label="关闭目录"
        >
          ✕
        </button>
      </div>

      <div className="toc-panel-content">
        {toc.map((item, index) => (
          <a
            key={item.id}
            ref={index === 0 ? firstItemRef : undefined}
            href={`#${item.id}`}
            className={`toc-item ${activeId === item.id ? 'toc-item-active' : ''}`}
            data-level={item.level}
            onClick={(e) => {
              e.preventDefault()
              onSelect(item.id)
            }}
            onKeyDown={(e) => handleKeyDown(e, item.id)}
            aria-current={activeId === item.id ? 'location' : undefined}
          >
            {item.text}
          </a>
        ))}
      </div>
    </aside>
  )
}

export default TocPanel
```

### 4.5 样式设计（修订：含响应式）

```css
/* src/renderer/src/assets/main.css 新增 */

/* ========== 浮动导航 ========== */

.floating-nav {
  position: absolute;
  right: 16px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 100;
}

.floating-nav-btn {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--bg-secondary);
  color: var(--text-primary);
  font-size: 18px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.floating-nav-btn:hover {
  background: var(--bg-hover);
  transform: scale(1.05);
}

.floating-nav-btn:focus {
  outline: 2px solid var(--accent-color);
  outline-offset: 2px;
}

.floating-nav-btn:active {
  transform: scale(0.95);
}

/* ========== 目录面板 ========== */

.toc-panel {
  position: absolute;
  right: 56px;
  top: 50%;
  transform: translateY(-50%);
  width: 280px;
  max-height: 60vh;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  overflow: hidden;
  animation: tocSlideIn 0.2s ease;
}

@keyframes tocSlideIn {
  from {
    opacity: 0;
    transform: translateY(-50%) translateX(10px);
  }
  to {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
  }
}

.toc-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
}

.toc-panel-title {
  font-weight: 600;
  font-size: 14px;
}

.toc-panel-close {
  width: 24px;
  height: 24px;
  border: none;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.toc-panel-close:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

.toc-panel-close:focus {
  outline: 2px solid var(--accent-color);
  outline-offset: 1px;
}

.toc-panel-content {
  max-height: calc(60vh - 50px);
  overflow-y: auto;
  padding: 8px 0;
}

/* ========== 目录项 ========== */

.toc-item {
  display: block;
  padding: 8px 16px;
  color: var(--text-secondary);
  text-decoration: none;
  font-size: 13px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  transition: all 0.15s ease;
  border-left: 2px solid transparent;
}

.toc-item:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

.toc-item:focus {
  outline: none;
  background: var(--bg-hover);
  color: var(--text-primary);
}

/* 当前位置高亮 */
.toc-item-active {
  background: rgba(0, 122, 255, 0.1);
  color: var(--accent-color);
  border-left-color: var(--accent-color);
  font-weight: 500;
}

/* 层级缩进 */
.toc-item[data-level="1"] { padding-left: 16px; font-weight: 600; }
.toc-item[data-level="2"] { padding-left: 28px; }
.toc-item[data-level="3"] { padding-left: 40px; font-size: 12px; }
.toc-item[data-level="4"] { padding-left: 52px; font-size: 12px; }
.toc-item[data-level="5"] { padding-left: 64px; font-size: 11px; }
.toc-item[data-level="6"] { padding-left: 76px; font-size: 11px; }

/* ========== 响应式设计 ========== */

@media (max-width: 768px) {
  .floating-nav {
    position: fixed;
    right: 16px;
    bottom: 24px;
    top: auto;
    transform: none;
    flex-direction: row;
  }

  .floating-nav-btn {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .toc-panel {
    position: fixed;
    right: 0;
    left: 0;
    bottom: 0;
    top: auto;
    transform: none;
    width: 100%;
    max-height: 70vh;
    border-radius: 16px 16px 0 0;
    animation: tocSlideUp 0.3s ease;
  }

  @keyframes tocSlideUp {
    from {
      opacity: 0;
      transform: translateY(100%);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
}

/* ========== 暗色模式 ========== */

@media (prefers-color-scheme: dark) {
  .toc-panel {
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  }

  .toc-item-active {
    background: rgba(10, 132, 255, 0.15);
  }
}
```

---

# 第二部分：HTML 导出增强（安全修订版）

## 五、安全问题分析

### 5.1 原方案安全漏洞

| 漏洞 | 风险等级 | 攻击向量 |
|------|----------|----------|
| SVG XSS 注入 | 高危 | `<img src=x onerror=alert(1)>` |
| JavaScript URL | 高危 | `click A "javascript:alert(1)"` |
| 错误信息 XSS | 高危 | 错误对象直接拼接到 HTML |
| foreignObject 注入 | 中危 | SVG 嵌入任意 HTML |

### 5.2 修复策略

1. **Mermaid 严格模式**：`securityLevel: 'strict'`
2. **SVG 清理**：使用 DOMPurify 移除危险元素
3. **错误信息编码**：HTML 转义
4. **CSP 头**：禁止内联脚本执行

---

## 六、安全实现方案

### 6.1 Mermaid 安全渲染器

```typescript
// src/renderer/src/utils/mermaidRenderer.ts

import DOMPurify from 'dompurify'
import mermaid from 'mermaid'

let initialized = false

/**
 * 安全初始化 Mermaid
 */
function initMermaidSecure(): void {
  if (initialized) return

  mermaid.initialize({
    startOnLoad: false,
    securityLevel: 'strict',  // 关键：严格安全模式
    maxTextSize: 50000,       // 限制输入大小
    maxEdges: 500,            // 限制复杂度
    flowchart: {
      htmlLabels: false,      // 禁用 HTML 标签
    },
  })

  initialized = true
}

/**
 * HTML 转义（用于错误消息）
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
  }
  return text.replace(/[&<>"']/g, c => map[c])
}

/**
 * 安全提取错误消息
 */
function getSafeErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    // 移除敏感信息
    const safeMsg = error.message
      .replace(/at\s+.*$/gm, '')    // 移除堆栈信息
      .replace(/\/[\w/.-]+/g, '')   // 移除文件路径
      .slice(0, 200)
      .trim()
    return escapeHtml(safeMsg)
  }
  return '渲染时发生错误'
}

/**
 * 清理 SVG 输出（防 XSS）
 */
function sanitizeSvg(svg: string): string {
  return DOMPurify.sanitize(svg, {
    USE_PROFILES: { svg: true, svgFilters: true },
    FORBID_TAGS: [
      'script',
      'foreignObject',
      'iframe',
      'object',
      'embed',
    ],
    FORBID_ATTR: [
      'onclick', 'onerror', 'onload', 'onmouseover',
      'onfocus', 'onblur', 'onmouseenter', 'onmouseleave',
    ],
    ALLOWED_URI_REGEXP: /^(?:(?:https?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))/i,
  })
}

/**
 * 验证 Mermaid 代码安全性
 */
function validateMermaidCode(code: string): { valid: boolean; error?: string } {
  if (code.length > 50000) {
    return { valid: false, error: '代码长度超出限制' }
  }

  // 检测危险模式
  const dangerousPatterns = [
    /click\s+\w+\s+["']javascript:/i,
    /click\s+\w+\s+["']data:/i,
    /<script[\s>]/i,
    /on\w+\s*=/i,
    /<iframe[\s>]/i,
    /<foreignObject[\s>]/i,
  ]

  for (const pattern of dangerousPatterns) {
    if (pattern.test(code)) {
      return { valid: false, error: '检测到不安全的内容' }
    }
  }

  return { valid: true }
}

/**
 * 安全渲染 Mermaid 为 SVG
 */
export async function renderMermaidToSvg(
  code: string,
  id: string
): Promise<string> {
  initMermaidSecure()

  // 验证输入
  const validation = validateMermaidCode(code)
  if (!validation.valid) {
    return `<div class="mermaid-error" role="alert">${escapeHtml(validation.error || '无效代码')}</div>`
  }

  try {
    // 生成安全的 ID
    const safeId = `mermaid-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`
    const { svg } = await mermaid.render(safeId, code)

    // 清理 SVG 输出
    return sanitizeSvg(svg)
  } catch (error) {
    const safeError = getSafeErrorMessage(error)
    return `<div class="mermaid-error" role="alert">图表渲染失败: ${safeError}</div>`
  }
}

/**
 * 判断是否是 Mermaid 代码
 */
export function isMermaidCode(code: string): boolean {
  if (!code || typeof code !== 'string') return false

  const lines = code.trim().split('\n')

  // 跳过注释找到第一个有效行
  const firstContentLine = lines.find(line => {
    const trimmed = line.trim()
    return trimmed && !trimmed.startsWith('%%')
  })

  if (!firstContentLine) return false

  const normalized = firstContentLine.trim().toLowerCase()

  // 有方向参数的图表
  const directedCharts = ['graph', 'flowchart']
  for (const chart of directedCharts) {
    if (normalized === chart ||
        (normalized.startsWith(chart) && /\s/.test(normalized[chart.length]))) {
      return true
    }
  }

  // 独立图表类型
  const standaloneCharts = [
    'sequencediagram', 'classdiagram', 'statediagram',
    'statediagram-v2', 'erdiagram', 'journey', 'gantt',
    'pie', 'gitgraph', 'mindmap', 'timeline',
    'quadrantchart', 'sankey', 'xychart', 'block',
  ]

  return standaloneCharts.some(chart =>
    normalized === chart || normalized.startsWith(chart + ' ')
  )
}

/**
 * HTML 实体解码（安全版本）
 */
function decodeHtmlEntities(text: string): string {
  const entities: Record<string, string> = {
    '&lt;': '<',
    '&gt;': '>',
    '&amp;': '&',
    '&quot;': '"',
    '&#39;': "'",
  }
  return text.replace(/&lt;|&gt;|&amp;|&quot;|&#39;/g, m => entities[m])
}

/**
 * 处理 HTML 中的所有 Mermaid 代码块
 */
export async function processMermaidInHtml(html: string): Promise<string> {
  initMermaidSecure()

  const mermaidRegex = /<pre\s+class="language-mermaid">\s*<code[^>]*>([\s\S]*?)<\/code>\s*<\/pre>/g

  const matches: { match: string; code: string; index: number }[] = []
  let m: RegExpExecArray | null
  let matchCount = 0
  const MAX_MATCHES = 100  // 限制数量，防止 DoS

  while ((m = mermaidRegex.exec(html)) !== null && matchCount < MAX_MATCHES) {
    const code = decodeHtmlEntities(m[1])
    if (isMermaidCode(code)) {
      matches.push({ match: m[0], code, index: m.index })
      matchCount++
    }
  }

  // 逆序处理，避免索引偏移
  for (let i = matches.length - 1; i >= 0; i--) {
    const { match, code, index } = matches[i]
    const svg = await renderMermaidToSvg(code, `mermaid-export-${i}`)
    const wrapper = `<div class="mermaid-container" role="img" aria-label="Mermaid 图表">${svg}</div>`
    html = html.slice(0, index) + wrapper + html.slice(index + match.length)
  }

  return html
}
```

### 6.2 修改 markdownRenderer.ts

```typescript
// 在 highlight 函数中添加 Mermaid 标记

highlight: (str: string, lang: string) => {
  // Mermaid 特殊处理：保留原始代码，标记为 mermaid
  if (lang === 'mermaid') {
    return `<pre class="language-mermaid"><code class="language-mermaid">${md.utils.escapeHtml(str)}</code></pre>`
  }

  if (lang && Prism.languages[lang]) {
    try {
      return `<pre class="language-${lang}"><code class="language-${lang}">${Prism.highlight(str, Prism.languages[lang], lang)}</code></pre>`
    } catch (e) {
      console.error('Prism highlight error:', e)
    }
  }
  return `<pre class="language-plaintext"><code>${md.utils.escapeHtml(str)}</code></pre>`
}
```

### 6.3 导出 HTML 模板（含 CSP）

```typescript
// main/index.ts - generateExportHTML 修改

function generateExportHTML(
  content: string,
  title: string,
  markdownCss: string,
  prismCss: string
): string {
  return `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'none';
    style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
    img-src 'self' data: https:;
    font-src 'self' https://cdn.jsdelivr.net;
    object-src 'none';
    base-uri 'self';
  ">
  <title>${escapeHtml(title)}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <style>
    /* ... 原有样式 ... */

    /* Mermaid 图表样式 */
    .mermaid-container {
      display: flex;
      justify-content: center;
      margin: 1.5em 0;
      overflow-x: auto;
    }

    .mermaid-container svg {
      max-width: 100%;
      height: auto;
    }

    .mermaid-error {
      color: #c53030;
      background: #fff5f5;
      border: 1px solid #feb2b2;
      padding: 12px 16px;
      border-radius: 6px;
      margin: 1em 0;
      font-size: 14px;
    }

    ${markdownCss}
    ${prismCss}
  </style>
</head>
<body>
  <div class="container">
    <div class="markdown-body">
      ${content}
    </div>
  </div>
</body>
</html>`
}
```

---

# 第三部分：文件变更清单

## 七、新增文件

| 文件 | 说明 | 优先级 |
|------|------|--------|
| `src/renderer/src/utils/slugify.ts` | 共享 slug 生成逻辑 | P0 |
| `src/renderer/src/utils/tocExtractor.ts` | 基于 Token 的目录提取 | P0 |
| `src/renderer/src/utils/mermaidRenderer.ts` | 安全 Mermaid 渲染 | P0 |
| `src/renderer/src/hooks/useTableOfContents.ts` | 目录状态管理 | P0 |
| `src/renderer/src/hooks/useActiveHeading.ts` | 当前位置追踪 | P1 |
| `src/renderer/src/hooks/useDebouncedValue.ts` | 防抖 Hook | P0 |
| `src/renderer/src/components/FloatingNav.tsx` | 浮动导航组件 | P0 |
| `src/renderer/src/components/TocPanel.tsx` | 目录面板组件 | P0 |

## 八、修改文件

| 文件 | 修改内容 | 优先级 |
|------|----------|--------|
| `src/renderer/src/App.tsx` | 集成 FloatingNav | P0 |
| `src/renderer/src/utils/markdownRenderer.ts` | Mermaid 代码块标记 + 共享 slugify | P0 |
| `src/main/index.ts` | 导出模板添加 CSP + Mermaid 样式 | P0 |
| `src/renderer/src/assets/main.css` | 浮动导航 + 目录面板样式 | P0 |
| `package.json` | 版本号 1.3.5 + 添加 dompurify 依赖 | P0 |
| `CHANGELOG.md` | 添加 v1.3.5 变更记录 | P0 |

## 九、新增依赖

```json
{
  "dependencies": {
    "dompurify": "^3.3.1"
  },
  "devDependencies": {
    "@types/dompurify": "^3.0.5"
  }
}
```

---

# 第四部分：测试计划

## 十、单元测试

### 10.1 tocExtractor.test.ts

```typescript
import MarkdownIt from 'markdown-it'
import { extractTocFromTokens } from './tocExtractor'

const md = new MarkdownIt()

describe('extractTocFromTokens', () => {
  describe('基础功能', () => {
    it('应正确提取多级标题', () => {
      const tokens = md.parse('# H1\n## H2\n### H3', {})
      const toc = extractTocFromTokens(tokens)

      expect(toc).toHaveLength(3)
      expect(toc[0]).toEqual({ id: 'h1', text: 'H1', level: 1 })
      expect(toc[1]).toEqual({ id: 'h2', text: 'H2', level: 2 })
      expect(toc[2]).toEqual({ id: 'h3', text: 'H3', level: 3 })
    })

    it('应处理中文标题', () => {
      const tokens = md.parse('# 你好世界', {})
      const toc = extractTocFromTokens(tokens)

      expect(toc[0].text).toBe('你好世界')
      expect(toc[0].id).toBe('你好世界')
    })
  })

  describe('边界情况', () => {
    it('应跳过代码块内的标题', () => {
      const markdown = '```\n# Not a heading\n```\n# Real heading'
      const tokens = md.parse(markdown, {})
      const toc = extractTocFromTokens(tokens)

      expect(toc).toHaveLength(1)
      expect(toc[0].text).toBe('Real heading')
    })

    it('应为重复标题生成唯一 ID', () => {
      const tokens = md.parse('# Example\n## Example\n# Example', {})
      const toc = extractTocFromTokens(tokens)

      expect(toc[0].id).toBe('example')
      expect(toc[1].id).toBe('example-1')
      expect(toc[2].id).toBe('example-2')
    })

    it('应处理空文档', () => {
      const tokens = md.parse('', {})
      const toc = extractTocFromTokens(tokens)

      expect(toc).toEqual([])
    })

    it('应提取标题中的纯文本（排除链接语法）', () => {
      const tokens = md.parse('# Check [link](url) here', {})
      const toc = extractTocFromTokens(tokens)

      expect(toc[0].text).toBe('Check link here')
    })
  })
})
```

### 10.2 mermaidRenderer.test.ts

```typescript
import { isMermaidCode, renderMermaidToSvg } from './mermaidRenderer'

describe('isMermaidCode', () => {
  describe('有效 Mermaid 代码', () => {
    const validCodes = [
      'graph TD\n  A --> B',
      'flowchart LR\n  Start --> End',
      'sequenceDiagram\n  Alice->>Bob: Hello',
      'pie\n  title Pets',
      '%% comment\ngraph TD\n  A-->B',
    ]

    validCodes.forEach(code => {
      it(`应识别: ${code.split('\n')[0]}`, () => {
        expect(isMermaidCode(code)).toBe(true)
      })
    })
  })

  describe('无效代码', () => {
    const invalidCodes = [
      'const graph = {}',
      'graphql query {}',
      '',
      '   ',
    ]

    invalidCodes.forEach(code => {
      it(`应拒绝: "${code.slice(0, 20)}"`, () => {
        expect(isMermaidCode(code)).toBe(false)
      })
    })
  })
})

describe('renderMermaidToSvg', () => {
  it('应生成包含 SVG 的输出', async () => {
    const svg = await renderMermaidToSvg('graph TD\n  A --> B', 'test-1')
    expect(svg).toContain('<svg')
  })

  it('SVG 不应包含 script 标签', async () => {
    const svg = await renderMermaidToSvg('graph TD\n  A --> B', 'test-2')
    expect(svg).not.toMatch(/<script/i)
  })

  it('应拒绝包含 JavaScript URL 的代码', async () => {
    const code = 'graph TD\n  A[Test]\n  click A "javascript:alert(1)"'
    const result = await renderMermaidToSvg(code, 'test-3')
    expect(result).toContain('mermaid-error')
  })

  it('错误消息应被 HTML 编码', async () => {
    const code = 'invalid <script>alert(1)</script>'
    const result = await renderMermaidToSvg(code, 'test-4')
    expect(result).not.toContain('<script>')
  })
})
```

### 10.3 FloatingNav.test.tsx

```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import FloatingNav from './FloatingNav'

describe('FloatingNav', () => {
  const mockRef = { current: document.createElement('div') }
  const markdown = '# Title 1\n## Subtitle\n# Title 2'

  describe('渲染', () => {
    it('应渲染导航按钮', () => {
      render(<FloatingNav containerRef={mockRef} markdown={markdown} />)

      expect(screen.getByLabelText('返回顶部')).toBeInTheDocument()
      expect(screen.getByLabelText('目录')).toBeInTheDocument()
      expect(screen.getByLabelText('跳到底部')).toBeInTheDocument()
    })

    it('无标题时应隐藏目录按钮', () => {
      render(<FloatingNav containerRef={mockRef} markdown="No headings" />)

      expect(screen.queryByLabelText('目录')).not.toBeInTheDocument()
    })
  })

  describe('交互', () => {
    it('点击目录按钮应展开面板', async () => {
      render(<FloatingNav containerRef={mockRef} markdown={markdown} />)

      await userEvent.click(screen.getByLabelText('目录'))

      expect(screen.getByRole('navigation', { name: '文档目录' })).toBeInTheDocument()
    })

    it('ESC 应关闭目录面板', async () => {
      render(<FloatingNav containerRef={mockRef} markdown={markdown} />)

      await userEvent.click(screen.getByLabelText('目录'))
      expect(screen.getByRole('navigation', { name: '文档目录' })).toBeInTheDocument()

      await userEvent.keyboard('{Escape}')
      expect(screen.queryByRole('navigation', { name: '文档目录' })).not.toBeInTheDocument()
    })
  })

  describe('可访问性', () => {
    it('目录按钮应有正确的 ARIA 属性', () => {
      render(<FloatingNav containerRef={mockRef} markdown={markdown} />)

      const tocButton = screen.getByLabelText('目录')
      expect(tocButton).toHaveAttribute('aria-expanded', 'false')
      expect(tocButton).toHaveAttribute('aria-controls', 'toc-panel')
    })

    it('目录项应支持键盘导航', async () => {
      render(<FloatingNav containerRef={mockRef} markdown={markdown} />)

      await userEvent.click(screen.getByLabelText('目录'))

      // 第一个目录项应自动获得焦点
      expect(screen.getByText('Title 1')).toHaveFocus()

      // Tab 到下一个
      await userEvent.tab()
      expect(screen.getByText('Subtitle')).toHaveFocus()
    })
  })
})
```

## 十一、E2E 测试要点

### 11.1 浮动导航

- [ ] 点击到顶按钮，验证滚动位置为 0
- [ ] 点击到底按钮，验证滚动到最底部
- [ ] 点击目录项，验证跳转到对应标题
- [ ] Tab 键在目录项间导航
- [ ] Enter 键激活目录项
- [ ] ESC 关闭目录面板并返回焦点
- [ ] 滚动时当前章节高亮更新
- [ ] 切换文件后目录自动更新
- [ ] 移动端视图正确显示

### 11.2 Mermaid 导出安全

- [ ] 导出 HTML 不执行内联脚本
- [ ] SVG 中不包含危险元素（script、foreignObject）
- [ ] 恶意 Mermaid 代码被正确拒绝
- [ ] 错误消息不泄露敏感信息
- [ ] CSP 头正确阻止脚本执行

---

# 第五部分：风险与审批

## 十二、风险评估（修订后）

| 风险 | 原方案 | 修订后 | 缓解措施 |
|------|--------|--------|----------|
| XSS 漏洞 | 高 | 低 | DOMPurify + 严格模式 + CSP |
| 目录跳转失败 | 高 | 低 | Token 流 + 共享 slugify |
| 性能问题 | 中 | 低 | 防抖 + IntersectionObserver |
| a11y 问题 | 高 | 低 | 完整键盘导航 + ARIA |
| 移动端体验 | 高 | 低 | 响应式设计 |

## 十三、审批确认

### 已确认事项

- [x] 图标方案：`▲` `≡` `▼` Unicode 字符
- [x] 目录面板：左侧弹出
- [x] 无标题时：隐藏目录按钮
- [x] Mermaid 方案：预渲染 SVG + DOMPurify 清理
- [x] 本地图片：v1.3.5 不处理，后续版本
- [x] 目录提取：改用 Token 流
- [x] 安全修复：全部采纳

### 审批状态

| 审批人 | 状态 | 日期 |
|--------|------|------|
| wj2929 | ⏳ 待审批 | - |

---

## 十四、实施计划

### 阶段一：安全基础（第 1 天）

| 任务 | 说明 |
|------|------|
| 添加 dompurify 依赖 | `npm install dompurify @types/dompurify` |
| 实现 mermaidRenderer.ts | 安全版本 |
| 修改导出模板添加 CSP | main/index.ts |

### 阶段二：目录功能（第 2 天）

| 任务 | 说明 |
|------|------|
| 实现 slugify.ts | 共享模块 |
| 实现 tocExtractor.ts | Token 流版本 |
| 实现 Hooks | useTableOfContents, useActiveHeading |

### 阶段三：UI 组件（第 3 天）

| 任务 | 说明 |
|------|------|
| 实现 FloatingNav.tsx | 含完整 a11y |
| 实现 TocPanel.tsx | 含键盘导航 |
| 添加样式 | 响应式设计 |

### 阶段四：集成测试（第 4 天）

| 任务 | 说明 |
|------|------|
| 单元测试 | 所有新模块 |
| 集成到 App.tsx | 功能联调 |
| E2E 测试 | 关键流程 |

### 阶段五：发布（第 5 天）

| 任务 | 说明 |
|------|------|
| 更新版本号 | 1.3.5 |
| 更新 CHANGELOG | 变更记录 |
| 构建发布 | GitHub Release |

---

**文档结束**

**修订版本**: v2.0
**修订日期**: 2026-01-07
**修订内容**: 根据多 Agent 评审意见全面修订
